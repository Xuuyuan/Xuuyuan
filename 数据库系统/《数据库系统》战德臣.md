# 数据库系统 战德臣
## 第2讲 数据库系统的结构抽象与演变
### 数据与模式
**模式**: 对数据库中数据所进行的一种结构性的描述/所观察到的数据的结构信息, 是对视图的抽象。  
**视图/数据**: 某一种表现形式下表现出来的数据库中的数据。  
**数据库的标准结构**: 三级模式、两层映像  
#### 三级模式
 * **外模式**:  对用户所看到的局部的数据的一种描述。  
 * **概念模式**: 数据之间内在的本质的联系(全局性的)。  
 * **内模式(物理模式)**: 存储在介质上的数据的结构描述。  
#### 两层映像
 * **E-C映像**: 外模式映射为概念模式的映像, 实现转换, 便于用户观察和使用。  
 * **C-I映像**: 概念模式映射为内模式的映像, 便于计算机存储和数据的处理。  
#### 两个独立性(三级模式、两层映像所实现)
避免应用程序在开发时不断修改  
 * **逻辑数据独立性**: 概念模式变化时, 可以不改变外部模式(只改变E-C Mapping), 从而无需改变应用程序。  
 * **物理数据独立性**: 内部模式变化时, 可以不改变概念模式(只改变C-I Mapping), 从而不改变外部模式。  
### 数据模型
**数据模型**: 规定模式统一描述方式的模型, 包括: 数据结构、操作和约束, 是对模式本身结构的抽象(而模式是对数据本身结构形式的抽象)。  
**ep. 关系模型**: 所有模式都可为抽象表的形式\[数据结构\], 而每一个具体的模式都是拥有不同列名的具体的表。对这些表形式的数据有哪些\[操作\]和\[约束\]。  
**ep. 理解**: 模式指代一定数据结构组成的抽象表(是对于数据的结构的抽象), 数据模型则定义了其统一描述的方式(是对模式的结构的抽象)。  
![图例理解](imgs/image-1.png)  
#### 三大经典数据模型
 * 关系模型: 表的形式组织数据(传统模式)
 ![关系模型示例](imgs/image.png)
 * 层次模型: 树的形式组织数据(实体型-系型,即节点-线, 以指针指向记录)
 ![层次模型示例](imgs/image-2.png)  
 PS: 模式可以理解为表头?
 * 网状模型: 图的形式组织数据(实体型-系型,即节点-线, 与层次模型类似, 如今使用不多)
 ![网状模型示例](imgs/image-3.png)  
 PS: 网状模型中指针需要用户建立。
### 发展史 30:00
#### 数据库技术的简要发展史
 * 数据库技术探索阶段(59-65/67): 正式提出Database概念
 * 数据库技术确立阶段(65/68-75): 研究形成关系数据库理论基础, 开始商用
 * 数据库技术成熟阶段(76-80s前期): 提出标准化数据库系统结构模型, 关系理论日益完善, 应用普及
 * 数据库技术深化发展阶段(85年以来): 数据库方法逐步理论化, 设计理论不断完善, 出现面向各行各业的专用数据库
#### 演变与发展
 1. 文件系统(存储基本以记录为单位, 用户无需考虑存储的物理细节。但数据与程序紧密结合, 共享性差、冗余度大)
 2. 层次、网状模型数据库(DBMS调用操作系统的函数对数据库存储和处理, 整体数据结构化, 多个应用程序可共享数据及数据结构的操作, 方便了应用程序的编写和使用。数据共享程度高、数据冗余度小、有统一的数据控制功能。但数据之间由复杂的指针系统维系, 结构描述复杂, 不能有效支持记录集合的操作)
 3. 关系模型数据库(不需要用户建立指针, 结构表征简单: 由属性的值表征, 不依赖于路径信息或过程信息, 支持非过程化的数据操作, 有效支持记录集合的操作。但必须按行列组织数据即1NF, 数据项不可再分)
 4. 对象关系数据库、面向对象数据库(引入了对象概念 - 行对象和列对象: 聚集对象与结构对象, 有效支持不满足1NF的数据项, 支持面向对象的特性: 类、继承、封装、多态)
 * XML数据库: 数据库的另一种形式, 被称为半结构化数据库, 封装在文件当中。数据与数据的语义合并在一起进行存储和处理。(类似HTML)
 * 由多种多样的数据库到多数据库(ODBC\JDBC | Oracle\Java)开放式互连。
 * 由普通数据库到与各种先进技术结合所形成的新型数据库。
### 总结
![第2讲课程的图总结](imgs/image-4.png)

## 第3讲 关系模型之基本概念
### 关系模型的概述
关系模型的三要素:   
 * **基本结构**: Table  
 * **基本操作**: 并、差、广义积、选择、投影、交、连接、除  
 * **完整性约束**: 实体完整性、参照完整性、用户定义完整性  
 关系代数: 基于集合的运算, 是一次一集合的操作, 是一种数学语言
 ![关系代数的解释](imgs/image-5.png)  

关系运算 -> 关系数据库语言 -> DBMS的实现  
### 什么是关系
**"表"的严格定义**
* 首先定义 列 的取值范围 域(一组值的集合), 集合中元素的个数称为域的基数。
* 定义元组及所有可能组合成的元组: **笛卡尔积**(根据N个域形成的所有可能的n-元组的集合)。笛卡尔积的每个元素(d1,d2,...,dn)称为一个n-元组, 每个值di叫做一个分量。
* 关系: 一组域的笛卡尔积的子集(笛卡尔积中抽出来的有意义的组合), 此时列名(对关系当中这一列的含义取名)称为属性名。

关系模式是稳定的(结构), 而关系是某一时刻的值, 是随时间可能发生变化的。  
**关系的特性**
* 列是同质: 每一列中的分量来自同一域, 是同一类型的数据(即每一列的数据类型必须相同)
* 不同列可来自同一个域: 每一列为一个属性, 不同的属性要给不同的属性名
* 列位置互换性、行位置互换性: 区分列靠列名、区分行靠某一或几列的值(关键字)
* 理论上, 关系的任意两个元组不能完全相同。(但Table不完全遵守这个特性)
* 属性不可再分特性: 又称为关系第一范式, 不能存在复合属性或属性再分的情况。

**关系中的概念**
* **候选码**: 关系中的一个属性组, 其值能**唯一标识**一个元组。(从该属性组中去掉任何一个属性都不再具有这个特性)这样的属性组称为候选码。有时关系中有很多组候选码。
* **主码(主键)**: 从若干候选码中选定一个作为主码, DBMS以主码为主要线索管理关系中的元组。
* **主属性与非主属性**: 包含在任何一个候选码中的属性称为主属性。
* **全码**: 所有属性构成这个关系的候选码(最极端的情况)。
* **外码(外键)**: 是关系R中的属性组但不是候选码, 但其与另一个关系S的候选码相对应。两个关系之间通常靠外码连接。**外码是连接两个或多个关系的纽带**。

关系是严格的数学的定义, 没有重复的原则, 但表是可以的。
![小结](imgs/image-6.png)  
### 关系模型中的完整性约束
**完整性约束规则**
* **实体完整性**: 关系的主码中的属性值不能为空值(不知道或无意义的值)。
* **参照完整性**: 外码可以为空值, 但不为空值时必须为外表的主码(例如分配学生所在的系)。
* **用户自定义完整性**: 用户针对具体的应用环境定义的完整性约束(例如年龄在多少之间\性别等)。此定义机制通常由DBMS提供使得用户可以自行定义、由DBMS检验操作的正确性。
### 总结
![第3讲课程的图总结](imgs/image-7.png)
## 第4讲 关系模型之关系代数
### 关系代数之基本操作
**关系代数运算的特点**  
* 基于集合, 提供了一系列的关系代数操作。
* 关系代数以一个或多个关系作为输入, 结果是一个新的关系。
* 具有一定过程性, 用对关系的运算来表达查询。
* 是一种抽象的语言, 是学习其它数据库语言的基础。

**基本操作**  
![关系代数的基本操作](imgs/image-9.png)  
* 并(*并相容) R∪S = S∪R: 将两个关系的元组合并成一个关系, 在合并时去重。用于查询XXX、XXX中至少参加了一个的信息。
* 差(*并相容) R-S / S-R: 是...但不含..., 用于查询只参加XXX而未参加XXX的信息。
* 广义笛卡尔积 R×S = S×R: 关系R中的元组与关系S中的元组进行所有可能的组合拼接构成。拼接后元组数目相乘, 度数相加。用于检索涉及多个表时串接的运算。是后续学习各种连接运算的基础。
* 选择 σcon(R): 从关系R中选择出满足给定条件condition的元组构成。  
![选择操作的数学描述](imgs/image-10.png)
* 投影 ΠA(R): 从关系R中选出属性包含在A中的列构成, 在合并时去重(因为对于关系来讲是集合, 在实际运用时默认不去重)。

**关系代数运算的约束**  
* 某些操作, 如并、差、交等, 需满足并相容性 -> 关系R和关系S的属性数目相同, 且第i个属性的域(domain, 在table中表现为type)相同

### 关系代数之扩展操作
**扩展操作**
* 交(*并相容) R∩S = S∩R = R-(R-S) = S-(S-R): 由同时出现在关系R和关系S中的元组构成, 用于查询既参加XXX又参加XXX的信息。
* θ-连接(theta-join): R与S的θ连接运算结果也是一个关系, 记作![θ运算示意图](imgs/image-11.png)。(可以理解为对笛卡尔积添加筛选条件)
* 更名 ρSC1(SC): 对表格进行更名以作为筛选条件的辅助操作。
* 等值连接(equi-join): θ-连接的特殊情况, 筛选条件中采用等值。
* 自然连接(natural-join): 等值连接的特殊情况, 要求关系R和关系S必须有相同的属性组B。R,S属性相同, 值必须相等才能连接。要在结果中去除重复的属性列。(实际上是最普遍使用的连接)
### 关系代数之组合与应用训练
练习章节, 略过。主要要求根据表达特别注意语义和顺序。  
**书写关系代数表达式的基本思路**  
![思路](imgs/image-12.png)  
### 关系代数之复杂扩展操作
 * 除 R÷S: 查询...全部的/所有的..., 要求除属性集S是被除属性集R的真子集。结果的度数k=n-m。  
   验证方法: (R÷S)×S的元组都在R的元组中。  
   ep: 查询选修了全部课程的学生的学号。
 * 外连接(outer-join): 与θ-连接相比, 连接时不会丢失元素(失配信息记为空值)。又进一步细分为左外连接、右外连接、全外连接。
### 总结
![章节重难点](imgs/image-8.png)  
**关系代数的基本书写思路**  
1. 选出将用到的关系/表
2. 做积运算(可用连接运算替换)
3. 做选择运算保留所需的行/元组
4. 做投影运算保留所需的列/属性

**章节回顾**  
![回顾](imgs/image-13.png)  
![关系模型的作用思想](imgs/image-14.png)
## 第5讲 关系模型之关系演算
### 关系演算之关系元组演算
按照谓词变量的不同, 可分为**关系元组演算**(以元组变量作为谓词变量的基本对象)和**关系域演算**(域变量)  
基本形式: {t|P(t)} 表示所有使谓词P为真的元组t的集合  

![公式形式的完整定义](imgs/image-16.png)  
注意运算符优先次序(括弧;θ;全称量词;取反;and;or)导致的结果差异！
* 被存在量词或全称量词限定的元组变量被称为**约束变量**, 否则被称为**自由变量**。
* **存在量词**: 全假则假, 一真则真; **全称量词**: 全真则真, 一假则假  

**这一段的训练题非常多, 涉及到离散数学/概率论中的逻辑。可以看原视频深入了解。**  
**四个最复杂的例子**
1. "全都学过": 视频44:09
  ![ep1](imgs/image-17.png)
2. "全没学过": 视频49:32
  ![ep2](imgs/image-18.png)
3. "至少有一学过" 视频52:40
  ![ep3](imgs/image-19.png)
4. "至少有一没学过" 视频53:50
  ![ep4](imgs/image-20.png)

元组演算公式与关系代数的等价性  
![等价性](imgs/image-21.png)  

### 关系演算之关系域演算
1. **关系域演算公式**  
  基本形式: {<x1,x2,...,xn>|P(x1,x2,...,xn)}  
  其中xi代表域变量或常量, P为以xi为变量的公式
2. **构造示例**  
  ![域演算的构造示例](imgs/image-22.png)
3. **基于关系域演算的QBE语言**
  * 特点: 操作独特, 基于屏幕表格的查询语言, 只需将条件填在表格中
  * 是一种高度非过程化的查询语言
  * 适合终端用户的使用
  * 操作框架由四个部分构成: 关系名区, 属性名区, 操作命令区, 查询条件区
  * 操作命令: P.(Print), D.(Delete), I.(Insert), U.(Update)
  * 查询条件形式为 θ 参量(省略θ则默认为=)
  * 示例元素与投影: 
    * 用任何一个值带有下划线表示, 被称为示例元素
    * 只用于占位(通过表格反映查询条件)
    * 符号也可写在操作区, 表示对整行生效
    * 可利用同一连接条件使用相同的示例元素, 实现多个表的连接  
  * PS: 视频1:23:00有误, 满足例子条件的应该放在同一行。视频中的表格实现的是年龄大于19岁或男同学。  
### 关系演算之安全性
**不产生无限关系和无穷验证的运算被称为是安全的**
 * 关系代数是一种集合运算, 是安全的(集合本身是有限的)
 * 关系演算不一定是安全的(R(t)是有限的, 但不在R(t)中的元素可能是无限的)
 
所以需要对关系演算施加约束条件, 即**安全约束有限集合DOM**: 其为一个有限集合, 其中的每个符号要么是公式中明显出现的符号, 要么是出现在公式中的某个关系R的某元组的分量。  
**安全元组演算表达式**  
![安全表达式解释](imgs/image-23.png)  
**安全域演算表达式**  
同理。课程视频中未介绍。
### 关于三种关系运算的观点
 * 关系运算有三种: 关系代数、关系元组演算和关系域演算
 * 三种关系运算都是抽象的数学运算, 体现了三种不同思维(以元组、集合、域变量为对象)
 * 三种运算之间是(有条件: 即安全的元组/域演算表达式)等价的
 * 三种运算都可以说是非过程性的: 域演算>元组演算>关系代数
 * 三种关系运算虽然是抽象的, 但是是衡量数据库语言完备性的基础
 * 数据库语言可以基于这三种抽象运算来设计
### 总结
![章节重难点](imgs/image-15.png)  
本讲主要是基于逻辑的思维, 讨论从关系演算->元组演算/域演算, 涉及到与、或、非、存在量词、全称量词。  
## 第6讲 SQL语言之概述
### SQL语言概述
**SQL语言的发展历史**
 * 1974年由Boyce和Chamber提出
 * 1975-1979年由San Jose研究室在System R首次实现, 称为Sequel -> SQL
 * 1986年ANSI/ISO推出SQL-86标准
 * 1989年ANSI/ISO推出SQL-89标准
 * 1992年进一步提出SQL标准: SQL-92, 也称SQL2(标准关系数据库语言)
 * 1999年进一步提出SQL标准: SQL-99, 也称SQL3(面向对象数据库/对象关系数据库)
 * SQL 2003/2006/2008(对数据库应用程序进行规范)
 * 另有SQL X/Open标准, 强调各厂商产品的可移植性, 只包含被各厂商广泛认可的操作 -> 标准使得用户可以学习标准规定的语言, 而无需关注具体的软件产品(具体应用依然略有差异)

**SQL语言的功能概述**
 * SQL语言是集DDL、DML、DCL于一体的数据库语言
 * SQL语言主要由9个单词引导的操作语句构成: 
   * **DDL**: Create, Alter, Drop - 模式的定义和删除
   * **DML**: Insert, Delete, Update, Select - 各种方式的更新与检索操作
   * **DCL**: Grant, Revoke - 安全性控制
 * 课程逐步递进: 交互式SQL -> 嵌入式SQL -> 动态SQL
 * **课程要求: 理解查询(增删改查)需求、用SQL精确表达**
### SQL语言之DDL-定义数据库
**建立数据库**: 包括 定义数据库和表(使用DDL), 向表中追加元组(使用DML)  
**创建数据库的简单语法形式**: create database 数据库名;  
**创建Table的简单语法形式**: create table 表名( 列名 数据类型 \[Primary key|Unique\] \[Not null\] \[,列名 数据类型 \[Not null\],...\])  
 * Primary key: 主键约束, 每张表只能创建一个。
 * Unique: 唯一性约束(即候选键), 每张表可以有多个。
 * Not null: 非空约束, 指该列不允许有空值出现。
 * 语法中的数据类型在SQL-92标准中被定义。
   * char(n): 固定长度字符串
   * varchar(n): 可变长度字符串
   * int: 整数, 有时不同系统为integer
   * numeric(p,q): 固定精度数字, 小数点左边p位,  右边p-q位
   * real: 浮点精度数字, 有时不同系统为float(n)
   * date: 日期 (ep. 2003-09-12)
   * time: 时间 (ep. 23:15:15:003)
* 和高级语言的数据类型总体一致, 但也有些差异

**向表中追加元组的简单语法形式**: insert into 表名\[(列名\[,列名\]...)\] values (值 \[,值\], ...);
 * 若列名未省略, 需与语句中列名的顺序一致; 若省略, 需与定义的列名顺序一致

**修正数据库**: alter table 表名 \[add {列名 数据类型,...}\] \[drop {完整性约束名}\] \[modify {列名 数据类型,...\]
 * add: 增加新列, drop: 删除完整性约束, modify: 修改列定义
 * **注意: 现在一般不再使用modify, 转而使用column修改。视频使用的SQL版本较老, 现今可能有部分语法更新, 以最新语法为准**  

**撤销基本表**: drop table 表名;  
**撤销数据库**: drop database 数据库名;  
有些数据库有操作多个数据库的能力, 对此可以以以下命令做切换:  
**指定当前数据库**: use 数据库名;  
**关闭当前数据库**: close 数据库名;  
### SQL语言之DML-操纵数据库
**检索语句的简单语法形式**: select 列名\[\[,列名\]...\] from 表名 \[where 检索条件\];
 * 在检索结果中可能有重复元组, 若要求无重复则需使用DISTINCT保留字。
 * 结果排序: order by 列名 \[asc|desc\] - asc或省略为升序, desc为降序
 * 模糊查询: 列名\[not\] like "字符串"
   * % 匹配零个或多个字符
   * _ 匹配任意单个字符
   * \\ 转义字符

**检索语句的多表联合查询**: select 列名 \[\[,列名\]...\] from 表名1,表名2,... where 检索条件;
 * 检索条件要包含连接的条件
 * 如两个表的属性名相同, 则需采用**表名.属性名**的方式来限定该属性名属于哪一张表
 * 如有表格重名/列名特别长的情况, 则需要用as设定别名以便区分(PS: 实际上在SQL中可以不添加as, 直接在空格后设定别名)

**增、删、改、查**
 * Insert: insert into 表名 (属性名\[, 属性名, ...\]) (值\[, 值, ...\])
 * Insert内可以嵌套Select语句
 * Delete: delete from 表名 \[where 条件表达式\]
 * 不添加条件表达式则会删除表中所有元组
 * Update: update 表名 set 列名=表达式 | (子查询) \[\[,列名=表达式|(子查询)\]\] \[where 条件表达式\];
 * 不添加where条件则会更新表中所有元组

**创建表(T-SQL语句)**: create table \[数据库名.所有者名.\]表名 ({<列名 数据类型>} \[缺省值\]\[约束\]\[是否为空\]);  
**创建、删除、修改约束: 在第9讲中详细介绍**  
![约束](imgs/image-25.png)  
### 典型DBMS交互环境 SQL Server介绍
SQL Server是Microsoft提供的一款关系数据库管理系统。
**系统数据库(SQL Server自带,自动安装)**
 * Master: 存储SQL Server中的元数据
 * Model: 模板数据库, 在创建新数据库时会复制此数据库作为基础
 * Msdb: 代理服务数据库
 * Tempdb: 临时数据库, 为临时数据提供存储空间

**SQL Server数据库**
 * 文件: 三种扩展名: 主数据库文件.mdf/辅助数据库文件.ndf/日志.ldf - 启动信息/所定义数据库的其它数据/事务日志文件
 * 页面: SQL Server存储的最小单位, 一页为8KB
 * 空间: 8个连续的页面即64KB数据, 是分配数据表存储空间的一种单位

**数据库授权**: grant 权限 on 表名 to 用户名  
 * 权限: select, update, insert, delete, exec, dri
### 总结
![章节重点与难点](imgs/image-24.png)  
![SQL: 结构化查询语言](imgs/image-26.png)  
## 第7讲 SQL语言之复杂查询与视图
### 子查询运用
**为什么需要子查询**
 * 集合成员资格判断
 * 集合之间的比较
 * 集合基数的测试(是否为空, 是否存在重复元组)

**(NOT) IN子查询**
 * 基本语法: 表达式 \[not\] in (子查询)
 * 语义: 判断某一表达式的值是否在子查询的结果中。

 * 带有子查询的selcet语句区分为内层和外层
 * 非相关子查询: 内层查询独立进行, 没有涉及任何外层查询相关信息的子查询
 * 相关子查询: 内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询, 外层向内层传递的参量需要使用外层的表名或表别名来限定
   * (只能由外层向内层传递参数, 而不能反之, 也称为变量的作用域原则)

**θ Some与θ All子查询**
 * 基本语法: 表达式 θ some/all(子查询) - θ是比较运算符
 * 语义: 将表达式的值与子查询的结果进行比较
 * 曾经有θany, 之后由于容易引起歧义, 改为了θsome
 * in 和 = some 等价, not in 和 <> all等价

**(NOT) EXISTS子查询**
 * 基本语法: \[not\] exists (子查询)
 * 语义: 子查询结果中有无元组存在

### 结果计算与聚集函数
**结果计算**
 * select子句后面可以是一些计算表达式或聚集函数, 表明在投影的同时进行计算
 * 内置的聚集函数: count(); sum(); avg(); max(); min()

### 分组查询与分组过滤
**分组查询与过滤**
 * 将检索到的元组按照某一条件进行分类, 同时处理多个组或集合的聚集运算
 * 基本语法: select ... from ... \[where ...\] group by 分组条件 \[having 过滤条件\]
 * 聚集函数不允许用于where语句中! 

### 利用SQL语言实现关系代数操作
**并-交-差处理**
 * 基本语法: 子查询 {Union \[ALL\] | Intersect \[ALL\] | Except \[ALL\] 子查询}
 * 不带ALL则默认自动删除重复元组, 若要保留则需要带有ALL
 * 交运算符intersect并没有增强sql的表达能力, 只是其增加了sql语言的不唯一性
 * 这些运算都在SQL-99中, 但有些DBMS不支持这些运算, 要注意。

**空值的处理**
 * 空值检测语法: is \[not\] null - 测试指定列的值是否为空值
 * 现行DBMS的空值处理
   * 除了is \[not\] null外不满足任何查找条件
   * 若参与算术运算, 则该算术表达式的值为null
   * 若参与比较运算, 则结果视为false
   * 若参与聚集运算, 则除了count(*)之外都忽略null

**内连接、外连接**
 * 基本语法: select 列名 from 表名1 \[NATURAL\] \[INNER|{LEFT|RIGHT|FULL}\[OUTER\]\] JOIN 表名2
 * 连接类型和连接条件  
 ![连接类型和连接条件](imgs/image-28.png)  
 ![连接时的公共属性](imgs/image-29.png)

**部分总结**  
![SQL-SELECT完整语法](imgs/image-30.png)

### 视图及其应用
 * 视图在SQL中只存储其由基本表导出视图所需要的公式, 其数据并不存储, 而是在运行过程中动态产生与维护的
 * 对视图数据的更改最终要反映在对基本表的更改上, 而有时视图定义的映射不可逆, 故视图的更新是比较复杂的问题
 * 定义视图: create view 视图名 \[(列名\[, 列名\] ...)\] as 子查询 \[with check option\]
 * 若属性名缺省, 则默认为子查询结果中的属性名
 * with check option指明当视图进行增改删时, 要检查是否满足视图定义中子查询中定义的条件表达式
 
 **SQL视图更新的可执行性**  
 ![SQL更新的可执行性](imgs/image-31.png)

 * 撤销视图: drop view 视图名
### 总结
![章节重难点](imgs/image-27.png)
![SQL: 结构化查询语言](imgs/image-32.png)
## 第8讲 SQL语言与数据库完整性和安全性
### 数据库完整性的概念及分类
**概念**
 * 数据库完整性指的是DBMS应保证的DB的一种特性——在任何情况下的正确性、有效性和一致性
 * 广义: 语义完整性、并发控制、安全空值、DB故障恢复
 * 狭义: 专指**语义完整性**, DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题(本讲专指此)
 * 不正当的数据库操作引发数据库完整性问题

**数据库完整性管理的作用**
 * 防止和避免数据库中不合理数据的出现
 * DBMS应尽可能地自动防止DB中语义不合理现象的出现

**怎样保证完整性**
 * 允许用户(DBA)定义一些完整性约束规则
 * 当有DB更新操作时, DBMS自动按照完整性约束条件进行检查以确保更新操作符合语义完整性

**完整性规则 ::=(O,P,A,R)**
 * O: 数据集合: 约束的对象
 * P: 谓词条件: 什么样的约束
 * A: 触发条件: 什么时候检查
 * R: 响应动作: 不满足时怎么办

**完整性的分类**
 * 按约束对象分类
   * 域完整性约束条件: 施加于某一列上(仅涉及到一列)
   * 关系完整性约束条件: 施加于关系/table上(可能涉及到多列)
 * 按约束来源分类
   * 结构约束: 来自模型的约束, 例如函数依赖约束、主键约束、外键约束
   * 内容约束: 来自用户的约束, 例如用户自定义完整性
 * 按约束状态分类
   * 静态约束: DB在任一时候均应满足的约束
   * 动态约束: 要求DB从一状态变为另一状态时应满足的约束

### SQL语言之列约束与表约束——静态约束
**SQL语言支持的约束类别**
 * 静态约束: 列完整性、表完整性
 * 动态约束: 触发器

**实现约束的方法——Create Table**
 * 表约束通过逗号区分开这一列, 列约束则是随每一列而定义
 * Col_constr列约束  
 ![col_constr](imgs/image-34.png)
 * table_constr表约束  
 ![table_constr](imgs/image-35.png)
 * 撤销/追加约束(不同系统可能有差异)
 ![alter_table](imgs/image-36.png)

**实现约束的方法——断言**
 * 就是一个谓词表达式, 表达了希望数据库总能表达的体哦阿健
 * 表约束和列约束就是特殊的断言
 * SQL还提供了复杂条件表达的断言: CREATE ASSERTION <断言名> CHECK <条件>
 * 断言测试会增加数据库维护的负担, 要小心使用复杂的断言
### SQL语言之触发器——动态约束
 * trigger是一种过程完整性约束, 可以在特定的时刻被自动触发执行
 * 基本语法  
 ![基本语法](imgs/image-37.png)

 * 新旧值用old_row_corr_name/new_row_corr_name/old_table_corr_name/new_table_corr_name区分
 * referencing new x, old y
### 阶段性总结
![总结](imgs/image-38.png)
### 数据库安全性的概念及分类
 * 概念: 数据库安全性是DBMS应该保证的数据库的一种特性: 免受非法、非授权用户的使用、泄漏、更改、破坏
 
**DBMS的安全机制**
 * 自主安全性控制: 存取控制: 通过权限在用户之间的传递使得用户自主管理数据库安全性
 * 强制安全性控制: 通过对数据和用户强制分类, 使得不同类别用户能访问不同类别的数据
 * 推断控制机制: 防止通过历史信息推断出不该被其知道的信息；防止通过一些信息推断出私密信息
 * 数据加密存储机制: 通过加密、解密保护数据

**DBA的责任和义务**
 * 划分好数据的安全级别以及用户的安全级别, 实施安全性控制

**数据库自主安全性机制的实现**
 * DBMS允许用户定义一些安全性控制规则(用SQL-DCL定义)
 * 安全性访问规则: AccessRule ::=(S,O,t,P)
   * S: 请求主体(用户)
   * O: 访问对象
   * t: 访问权利
   * P: 谓词
 * AccessRule通常存放在数据字典或系统目录中, 构成了所有用户对DB的访问权利
 * 用户多时, 可以按用户组建立访问规则

![example](imgs/image-39.png)  
![example_2](imgs/image-40.png)

 * 亦可使用视图(view)进行安全性控制
 * 用户定义视图后，其便成为一个新的数据对象，参与到存储矩阵与能力表中描述
### SQL语言之安全性实现
**SQL语言的用户与权利**  
![用户与权利](imgs/image-41.png)

**SQL-DCL的命令及其应用**  
![grant](imgs/image-42.png)  
 * 授予视图权利不代表授予基本表权利
 * 授权者授予的权利必须是授权者已有的权利

(public为授权给所有用户)  
![revoke](imgs/image-43.png)

**授权的传播范围**  
![传播范围](imgs/image-44.png)  
 * 当一个用户的权利被收回时, 通过其传播给其它用户的权利也将被收回

**强制安全性机制**
 * 通过对数据对象进行安全性分级: Top Secret/Secret/Confidential/Unclassified
 * 同时对用户也进行上述的安全性分级
 * 强制实现不同级别用户访问不同级别数据的一种机制
 * 但是高级别用户不允许写低级别数据
 * DBMS引入强制安全性机制, 可以通过扩展关系模式来实现, 使得关系中的每个元组扩展为带有安全分级的元组
### 阶段性总结
![总结](imgs/image-45.png)
### 总结
![章节重难点](imgs/image-33.png)
## 第9讲 嵌入式SQL语言之基本技巧
### 嵌入式SQL语言概述
**交互式SQL语言的局限**
  * 大部分普通用户难以使用
  * 特别复杂的检索结果难以用一条交互式SQL语句完成

**高级语言 + SQL语言**
  * 既继承高级语言的过程控制性
  * 又结合SQL语言的复杂结果集操作的非过程性
  * 同时又为数据库操作者提供安全可靠的操作方式: 通过应用程序进行操作

**典型特点(以宿主语言C语言为例)**
  * exec sql引导SQL语句
  * 增加into子句: 指出接收SQL语句检索结果的程序变量
  * 由冒号引导的程序变量

**高级语言中使用嵌入式SQL语言需要解决的问题**
  * 如何与数据库连接和断开连接
  * 如何将宿主程序的变量传递给SQL语句
  * SQL语句如何执行
  * 如何将SQL检索到的结果传递回宿主程序进行处理
  * 静态SQL, SQL语句中的常量更换为变量
  * 宿主程序如何知道SQL语句的执行状态, 是否发生错误
  * 动态SQL, 依据条件动态构造SQL语句, 但欲访问的表名和字段名对编程者是已知的
  * 动态SQL, 依据条件动态构造SQL语句, 但欲访问的表名和字段名对编程者是未知的
### 变量声明与数据库连接
**变量赋值时需要注意**
  * 宿主程序的字符串变量长度应比字符串字段的长度多1个(终止符\\0)
  * 宿主程序变量类型与数据库字段类型之间有些是有差异的, 有些DBMS可以支持自动转换, 有些不能
  * 声明的变量可以在宿主程序中赋值, 然后传递给SQL语句

**程序与数据库的连接和断开**
  * 在嵌入式SQL程序执行前要先连接数据库
  * 连接语法(SQL标准中所建议的)
    * exec sql connect to target-server as connect-name user user-name;
    * exec sql connec to default;
  * 断开连接语法(SQL标准中所建议的)
    * exec sql disconnect connect-name;
    * exec sql disconnect current;

**SQL语句的执行和撤销**
 * 在执行过程中必须有提交和撤销语句才能确认其操作结果
 * SQL执行的提交: exec sql commit work;
 * SQL执行的撤销: exec sql rollback work;

**事务的概念与特性**
 * 概念: (管理员角度)是一个存取或改变数据库内容的程序的一次执行(可以是一条或多条SQL语句)
 * 概念: (DBMS角度)是数据库管理员提供的控制数据操作的一种手段, 以便数据库管理系统能提供一致性状态转换的保证
 * (要保证一组操作或者全都执行, 或者都不执行)
 * 任何一条数据库操纵语句都会引发一个新事务的开始, 而事务的结束需要通过commit或rollback确认
 * 特性(ACID)
   * A原子性(保证事务的一组更新操作原子不可分)
   * C一致性(保证事务的操作状态正确)
   * I隔离性(保证并发执行的多个事务之间互相不受影响)
   * D持久性(保证已提交事务的影响是持久的, 被撤销事务的影响是可恢复的)
 * 具有ACID特性的若干数据库基本操作的组合体被称为事务
 * 事务处理是DBMS的核心技术
 * 示例
   * 引入SQLCA
   * 设置声明变量
   * 设置SQL错误捕获语句
   * 连接数据库
   * 设置SQL语句, 进行提交
   * 断开连接
### 数据集与游标
 * 检索单行结果, 可将结果之间传送到宿主语言的变量中
 * 检索多行结果, 则需使用游标(cursor)
   * 游标是指向某检索记录集的指针
   * 通过这个指针的移动, 每次读一行, 处理一行, 再读一行,...,直至处理完毕
   * 读一行操作是通过fetch...into语句实现的
   * 记录集有结束标识EOF, 用来标记后面已没有记录了
 * 游标的使用需要先定义, 再打开, 再处理数据, 最后关闭
 * 游标可以定义一次, 多次打开, 多次关闭
 * cursor的定义: exec sql declare cursor_name cursor for ...;
 * cursor的打开和关闭: exec sql open/close cursor_name;
 * cursor的数据读取: exec sql fetch cursor_name into host-variable, \[host-variable,...\];
### 可滚动游标与数据库的增删改
 * 标准的游标始终是自开始向结束方向移动的; 一条记录只能被访问一次; 再次访问该记录只能关闭游标后重新打开
 * ODBC提供了可滚动cursor的解决方案。许多DBMS不支持可滚动游标, 但是通过ODBC可以使用该功能
 * 新增\[SCROLL\]选项
   * NEXT向结束方向移动一条
   * PRIOR向开始方向移动一条
   * FIRST回到第一条
   * LAST移动到最后一条
   * ABSOLUT value_spec 定向检索指定位置的行
 * 可滚动游标移动时需要判断是否到结束或起始位置(EOF/BOF, 不需区分则可通过whenever not found语句设置来检测)
### 数据的删除与更新
 * 查找删除: 与交互式delete语句相同
 * 定位删除: 删除游标位置的数据(where current of delcust)
 * 查找更新: 与交互式update语句相同
 * 定位更新: 更新游标位置的数据(where current of declust)
 * 插入: 与交互式insert into语句相同
### 状态捕获及错误处理机制
 * 状态: 是嵌入式SQL语句的执行状态, 尤其指一些出错状态
 * 在嵌入SQL中, 状态捕获与处理的构成
   * 设置SQL通信区(exec sql include sqlca;)
   * 设置状态捕获语句(exec sql whenever sqlerror goto report_error;)
   * 状态处理语句(report_error: exec sql rollback;)
 * SQLCA是一个已被声明果的具C语言的结构形式的内存信息区, 是DBMS与宿主程序之间交流的桥梁
 * 状态捕获语句: exec sql whenever condition action; 设立条件陷阱
   * SQLERROR: 检测是否有SQL语句出错, 具体意义依赖于DBMS
   * NOT FOUND: 没有相应的结果记录
   * SQLWARNING: 不是错误, 但是应当引起注意的条件
   ---
   * CONTINUE: 忽略条件或错误, 继续执行
   * GOTO 标号: 转移到标号所指示的语句
   * STOP: 终止程序运行、撤销当前工作、断开数据库连接
   * DO/CALL: 调用宿主程序的函数进行处理, 函数返回后从引发该condition的SQL语句之后的语句继续执行
 * 状态捕获语句whenever的使用容易引发无限循环, 在处理函数中忽略其中的错误可避免无限循环
 * 状态记录方法
   * sqlcode: >0:warning;<0:error;==0:successful
   * sqlca.sqlcode
   * sqlstate
### 总结
![重难点](imgs/image-46.png)  
![基本问题](imgs/image-47.png)  
本讲讲解了问题1-6。  
![嵌入式SQL](imgs/image-48.png)
## 第10讲 嵌入式SQL语言之动态SQL
### 动态SQL的概念和作用
 * 静态SQL: SQL语句在程序中已经按要求写好, 只需要把一些参数通过变量传递给嵌入式SQL语句
 * 动态SQL: SQL语句可以在程序中动态构造, 形成一个字符串再交给DBMS执行
### SQL语句的动态构造
### 动态SQL语句的执行方式
 * 立即执行语句: 运行时编译并执行
 * Prepaer-Execute-Using: 先编译, 编译后的SQL语句允许动态参数, 用USING语句将动态参数值传送给编译好的语句
### 数据字典与SQLDA
 * 数据字典(系统目录): 是系统维护的一些表或视图的集合, 存储了数据库中各类对象的定义信息, 这些信息又称为数据的元数据
   * 包含与关系相关的信息
   * 包含用户与账户信息, 包括密码
   * 统计与描述性数据
   * 物理文件组织信息
   * 索引相关的信息
 * 数据字典也是存储在磁盘上的关系, 但是专为内存高效访问而设计的特定的数据结构
 * 模式是指某一用户所设计和使用的表、索引及其它与数据库有关的对象的集合, 完整名应是: 模式名.表名
 
 * SQLDA: SQL描述符区域, 是一个内存数据结构, 装载关系模式的定义信息
### ODBC/JDBC简介
 * ODBC是一种标准————不同语言的应用程序与不同数据库服务器之间通讯的标准
 * 当应用程序调用ODBC API时, ODBC API会调用具体DBMS Driver库函数, 库函数则与数据库服务器进行通讯, 执行相应请求并返回结果
   * 应用程序通过SQLExecDirect()向数据库发送SQL命令
   * 使用SQLFetch()获取产生的结果元组
   * 使用SQLBindCol()绑定C语言变量与结果中的属性
 * JDBC是Java版的应用程序接口API, 提供了Java应用程序与数据库服务器的连接和通讯能力
 * JDBC分成两个程序包: Java.sql 核心API/Javax.sql 可选扩展API
 ---
 * 嵌入式SQL的思维模式: 建立数据库连接->声明一个游标->打开游标->获取一条记录->关闭游标->断开数据库连接
### 总结
![章节重难点](imgs/image-49.png)
![嵌入式SQL](imgs/image-50.png)
## 第11讲 数据建模: 思想与方法(数据库设计的抽象与表达方法)
### 为什么要数据建模和数据库设计
 * 需求的理解和表达是很重要的
 * 表达计算机世界的模型称数据模型; 表达信息世界的模型称概念数据模型, 简称概念模型
 * 信息世界是对现实世界的理解与抽象
 * 数据建模 -> 数据库设计
 * 数据建模是抽象, 抽象是理解-区分-命名-表达
### ER模型-数据建模之基本思想
 * Entity-Relationship Model 实体联系模型
 * 基本观点: 世界是由一组称作实体的基本对象和这些对象之间的联系构成的
 * 基本概念: 实体、属性、联系、关键字/码
 ---
 * 实体: 客观存在并可相互区分的事务
 * 实体有类(实体, 实体的型)和个体(实体的实例, 实体的值)的概念
 * 实体用属性来刻画: 属性是实体所具有的某一方面的特性
    * 属性分为单一属性和复合属性, 在关系模型中复合属性一定要转化为单一属性(1NF)
    * 属性还分为单值属性和多值属性, 比如一个人可能有多个电话号码。在关系模型中同样需要转化为单值属性。
    * 属性分为可空值属性和非空值属性
    * 属性分为原始属性和导出属性(由其它属性计算而得的)
 * 实体中的特殊属性: 关键字/码, 实体中能用其值唯一区分开每一实例的属性或属性组合
 * 实体之间是有联系的: 指一个实体的实例和其它实体实例之间所可能发生的联系
 * 参与发生联系的实体的数目, 称为联系的度或元。联系有一元联系、二元联系和多元联系 | 实体是相对稳定的, 但联系是多样化的
 * 角色: 实体在联系中的作用称为实体的角色。显式指明其角色以在同一实体的不同实例参与一个联系时区分各实例参与联系的方式
 * 实体之间的二元联系有一对一、一对多、多对多的联系
 * 联系的基数: 实体实例之间的联系的数量, 即一个实体的实例通过一个联系能与另一实体中相关联的实例的数目(关系到怎么保存)
 * 联系的基数还要区分对每个实体的实例而言是否必须存在(完全参与联系: 最小基数1开始/部分参与联系: 最小基数0开始)(关系到空值的处理)
### ER模型-表达方法之Chen方法
 * 实体: 矩形框
 * 属性: 椭圆(用于刻画实体的)
   * 多值属性: 双线椭圆
   * 导出属性: 虚线椭圆
 * 关键字/码: 下划线
 * 连接实体和属性: 直线
 * 联系: 菱形框
 * 连接实体与联系: 直线
 * 连接联系与属性: 直线
 * 复合关键字: 标有相同数字
 * 多组关键字: 标有不同数字
 ---
 可采用的方法1
 * 一对一的联系: 用联系指向两个实体
 * 一对多的联系: 指向1端为箭头直线, 指向多端为直线
 * 多对多的联系: 无箭头直线
 * 完全参与联系: 双直线
 * 部分参与联系: 单直线

可采用的方法2
 * 1端实体-直线旁标1
 * 多端实体-直线旁标m或n
---
 * 联系也需要命名和表达, 联系也可能需要属性来刻画
---
运用ER模型理解需求并建模
 * 理解需求, 寻找实体: 能用一个个、一件件等重叠量词形容的称为实体
 * 用属性刻画每一个实体
 * 确定每一个实体的关键字/码
 * 数据建模的重点是分析实体之间的联系
 * 检查ER图是否覆盖了需求(对需求的理解和表达, ER图的绘制要符合规范)
### ER模型-表达方法之Crow's foot方法
 * 实体: 矩形框, 实体的名称写在横线上面
 * 属性: 实体框横线的下面
 * 关键词: 属性下加下划线
 ---
 * 联系用一个菱形框表示, 也可以将菱形框省略而直接以联系名替代
 * 联系的基数表示方法  
 ![基数表示](imgs/image-52.png)
 * 一种图形表示着一类业务规则
### 数据建模之案例讲解
### 数据库设计中的抽象
 * 抽象与具体化: 考虑信息的取舍
   * 数据库设计往往因为忽视了信息的细致分析而造成设计失误
   * 数据库设计能力的高低往往体现在信息的正确分析上, 体现在理解现实世界能力的高低
 * 现实世界->(抽象、概括为)信息世界->(抽象、概括为)计算机世界
 * 将可无限扩展的内容或内容无法枚举的情况, 抽象为可有限描述的概念
 * 越抽象, 语义信息越少, 概括性越高, 越反映共性信息, 表征的范围越大
 * 检验抽象正确性的方法: 能抽象化, 也能还原为具体化
 * 现实的抽象与描述需要遵循统一的数据模型(为了信息交流、信息共享)
   * 统一的概念与统一的表达方法
 * 数据模型是一组相互关联且已严格定义的概念集合, 是用于刻画或描述现实世界、信息世界或计算机世界的模型
 * 数据模型: 表达计算机世界的模型; 概念模型: 表达信息世界的模型
 * 建模的不同层次: 模型与元模型, 模型与实例
### 总结
![章节重难点](imgs/image-51.png)  
![小结](imgs/image-53.png)  
![本讲内容](imgs/image-54.png)
## 第12讲 数据建模: 工程化方法及案例分析
IDEF1x是将E-R模型扩充语义含义而形成的(是E-R图的细化), 是一种进行数据建模或数据库工程化的方法
### IDEF1x两种实体的区分
 * 独立标识符实体/独立实体——强实体: 一个实体的实例都被唯一标识而不决定于它与其它实体的联系
 * 从属标识符实体/从属实体——弱实体: 一个实体的实例的唯一标识需要依赖于该实体与其它实体的联系(ep. 一份合同中的一项项条目)
 * 从属实体需要从其它实体继承属性作为关键字的一部分, 主关键字包含了外来属性的实体为从属实体
 * 独立实体用直角方形框, 从属实体用圆角方形框
 * 独立实体的主关键字没有外键, 从属实体的主关键字含有外键
 * 关于属性的工程化要求  
 ![要求](imgs/image-56.png)
 * 关于关键字的工程化要求  
 ![要求](imgs/image-57.png)
 * 外来关键字: (FK) 是其它实体的关键字, 工程化要求  
 ![要求](imgs/image-58.png)
### IDEF1x的标定联系与非标定联系
 * 联系: 实体之间的一种连接关系
 * 标定联系: 子实体的实例都是由它与父实体的联系而确定。父实体的主关键字是子实体主关键字的一部分。
 * 非标定联系: 子实体的实例能够被唯一标识而无需依赖与其实体的联系, 父实体的主关键字不是子实体的主关键字。
 * 标定联系用实直线表示,  非标定联系用虚直线表示。在子实体一侧有圆圈, 联系名标注在直线旁
 * 工程化要求  
 ![要求](imgs/image-59.png)
### IDEF1x的非确定联系
 * 实体之间多对多的联系, 必须分解为若干个一对多的联系来表达
 * 非确定联系通过引入相交实体(相关实体)来分解为若干个一对多的联系来表达
 * 工程化要求  
 ![要求](imgs/image-60.png)
### IDEF1x的分类联系
 * 一个一般实体实例及多个分类实体实例构成的联系
 * 用于区分不同分类的属性, 称为鉴别器属性
 * 具体化: (自顶向下)实体的实例集中, 某些实例子集具有区别于该实例集内其它实例的特性, 可以根据这些差异特性对该实例集进行分组/分类, 这一过程称为具体化
 * 泛化: (自底向上)若干个实体集根据共有的性质, 可以合成较高层的实体。泛化是一个高层实体与若干个低层实体之间的包含关系
 * 在E-R图中用标记为ISA的倒三角形表示。
 * 高层实体的属性被低层实体自动继承, 低层实体特有的性质仅适用于某个特定的低层实例。
---
 * 完全分类联系: 分类完全集, 使用一圆圈带两个横线来刻画。
 * 非完全分类联系: 分类非完全集, 使用一圆圈带一个横线来刻画。
 * 分类实体必须具有特有的属性, 否则分类没有意义
---
 * 规则  
 ![规则](imgs/image-61.png)
### IDEF1x建模之案例讲解
 * 作用/角色: 当一个实体与其父实体有多种联系时, 需使用"作用/角色"来区分每一种联系
 * 仔细分析信息源, 源可能是由若干实体合并后形成的, 实体是从源中按实体规则提取出来的
 * 仓储系统的数据模型  
 ![数据模型](imgs/image-63.png)
### IDEF1x建模之案例作业点评
 * 通过IDEF1x图理解需求
 * 读图
   * 检查每个实体能否用重叠量词形容
   * 检查实体的关键字能否唯一确定每个实例
   * 检查实体之间联系绘制及命名的正确性
   * 检查属性继承的正确性
 * 不要把IDEF1x图当作流程图
### 总结
![章节重难点](imgs/image-55.png)  
![本讲学习内容](imgs/image-62.png)
## 第13讲 数据库设计过程
### 数据库设计过程与设计方法
 * 设计过程: 
   * 需求分析(收集需求和理解需求, "源")
   * 概念数据库设计(建立概念模型, "E-R图/IDEF1x图的绘制")
   * 逻辑数据库设计(建立逻辑模型, "关系模式", 包含全局模式和用户模式)
   * 物理数据库设计(建立物理模型, "Create Table", 包含物理数据组织等, 依赖于具体的DBMS)
---
  * 需求分析
    * 目标: 理解企业、企业业务过程与数据处理流程、理解数据处理的性能需求, 形成"源"清单和"属性"清单以及相关的详细描述
    * 对属性的命名要规范且含义明确, 尤其要注意多含义属性
    * 了解不同岗位划分->收集源形成源表->理解每一个源->形成并提交需求分析报告
  * 概念数据库设计
    * 目标: 进一步深入理解企业, 对信息源进行抽象, 发现信息之间的内在本质联系
    * 设计思路: 先局部后全局/先全局后局部 - 需求调研/合并局部需求/设计概念数据库模式/设计外部模式或视图
    * 局部E-R模式设计: 确定范围->实体定义->联系定义->属性分配->全局E-R模式设计
    * 全局E-R模式设计: 确定公共实体类型->合并两个局部E-R模式->检查并消除冲突->全局E-R模式优化
    * 消除冲突: (属性) 属性域的冲突/属性取值单位的冲突 (结构) 同一对象在不同应用中的抽象不同/同一实体在不同E-R图中的属性组成不同/实体之间的联系在不同E-R图中呈现不同类型 (命名)同名异义/异名同义
    * 全局E-R模式优化: 合并实体类型->消除冗余属性->消除冗余联系
    * 依据需求分析报告->识别实体与联系->绘制E-R图/IDEF1x图 用图表达业务规则->定义实体、联系及实体的属性构成->形成并提交概念数据库设计报告
  * 逻辑数据库设计
    * 目标: 用指定DBMS要求的模式描述方法, 给出概念数据库的逻辑模式描述
    * 依据概念数据库设计报告->转换成关系模型->检查逻辑数据库设计的正确性->定义全局模式和外模式->形成并提交逻辑数据库设计报告
  * 物理数据库设计
    * 目标: 结合指定DBMS物理数据库管理方法, 给出概念数据库的物理模式描述
    * 设计用户视图及访问控制规则, 以进行安全性控制->建立索引->设计使数据库运行达到最佳效率的措施->设计备份和恢复的步骤
    * 依据逻辑数据库设计报告->利用具体DBMS创建数据库/表->确定物理存储方式与存储空间->创建索引、视图->形成并提交物理数据库设计报告
### E-R图/IDEF1X向关系模式的转换
  转换的基本规则(E-R)
  * 实体-属性-关键字的转换
  * 复合属性的转换: 将每个分量属性作为复合属性所在实体的属性/将复合属性本身作为所在实体的属性 二选一
  * 多值属性的转换: 将多值属性与所在实体的关键字一起组成一个新的关系
  * 联系的转换
    * 一对一联系: (双方均部分参与)将联系定义为一个新的关系, 属性为参与双方的关键字属性; (一方全部参与)将联系另一方的关键字作为全部参与一方关系的属性
    * 一对多联系: 将单方参与实体的关键字作为多方参与实体对应关系的属性
    * 多对多联系: 将联系定义为新的关系, 属性为参与双方实体的关键字
  * 弱实体的转换: 所对应关系的关键字由弱实体本身的区分属性再加上所依赖的强实体的关键字构成
  * 泛化与具体化实体的转换: 高层实体和低层实体分别转为不同关系, 低层实体所对应的关系包括高层实体的关键字
    * 如果泛化实体实例是具体化实体实例的全部, 则可以不为高层实体建立关系, 低层实体所对应的关系包括上层实体的所有属性
  * 多元联系的转换
    * 多元联系可以通过继承参与联系的各个实体的关键字而形成新的关系, 这些继承过来的关键字可以作为新关系的关键字, 也可以新增一个区分属性作为关键字
  
  转换的基本规则(IDEF1x)
  * 只需要关注实体转换成关系, 而联系无需关注(联系的信息以及融入相关实体的关系描述中)
### 不正确数据库设计引发的问题及其解决
  * 不正确设计数据库引发的问题
    * 冗余: 数据库中存在大量冗余
      * 受控冗余: 实际上是联系的一个属性
      * 非受控冗余: 当数据发生改变时, 冗余数据同步更新困难
    * 插入异常: 插入数据时因为信息不完整而无法录入
    * 删除异常: 删除数据时关系到其它数据 ep. 某系所有同学被删除后该系的数据随之消失
  * 如何避免问题
    * 设计满足规范性, 由DBMS或数据库本身来保证
    * 设计不满足规范性, 由使用者或应用程序员使用过程中加以注意
  * 什么是规范的数据库设计
    * 需要分析数据库中的属性在取值方面的依存关系
    * 数据库设计理论: 数据依赖理论、关系范式理论、模式分解理论
  ### 总结
![章节重难点](imgs/image-64.png)  
![本讲学习内容](imgs/image-65.png)
## 第14讲 函数依赖及其公理/定理
### 函数依赖
设R(U)是属性集合U={A1,A2,...,An}上的一个关系模式, X,Y是U上的两个子集。若对R(U)的任意一个可能的关系r, r中不可能有两个元组满足在X中的属性值相等而在Y中的属性值不等, 则称为"X函数决定Y"或"Y函数依赖于X", 记作$X \to Y$
  * 函数依赖的分析取决于对问题领域的限定和分析, 取决于对业务规则的正确理解
  * 设计关系模式时, 除了给出属性全集之外, 还需给出数据依赖集合
  * 函数依赖的特性
    * 对$X \to Y$ , 但 $X \notin Y$ , 则称$X \to Y$ 为非平凡的函数依赖
    * 若$X \to Y$ , 则任意两个元组, 若X上值相等, 则Y上值必然相等, 则称X为决定因素
    * 若$X \to Y$ , $Y \to X$  , 则记作 $X \leftrightarrow Y$
    * 若Y不函数依赖于X, 则记作$X \nrightarrow Y$
    * $X \to Y$ , 有基于模式R的, 则要求对任意的关系r成立; 有基于具体关系r的, 则要求对某一关系r成立
    * 如一关系r的某属性集X, r中根本没用X上相等的两个元组存在, 则$X \to Y$ 恒成立
  * 重要的概念
    * 候选键: 设K为R(U)中的属性或属性组合, 若K能够完全决定U, 则称K为R(U)上的候选键
      * 可任选一候选键作为R的主键
      * 包含在任一候选键中的属性称为主属性, 其它属性称为非主属性
      * 若K是R的一个候选键, $S \supset K$, 则称S为R的一个超键(没有最小性要求)
    * 外来键: R(U)中的属性或属性组合X并非R的候选键, 但X是另一关系的候选键, 则X为R的外来键(外键)
    * 逻辑蕴涵: 设F是关系模式R(U)中的一个函数依赖集合, 若满足F的每个关系均满足$X \to Y$ ,则说F逻辑蕴涵$X \to Y$
    * 函数依赖闭包: 被F逻辑蕴涵的所有函数依赖集合称为F的闭包(Closure), 记作$F^+$ 。若$F^+=f$ , 则说F是一个全函数依赖族
### 完全函数依赖与传递函数依赖
 * 部分(p)或完全(f)函数依赖
 * 传递函数依赖: $X \to Y, Y \to Z, Y \notin X, Z \notin Y, Z \notin X, Y \nrightarrow X$ , 则称Z传递函数依赖于X
### 关于函数依赖的公理和定理
  * Armstrong公理
    * 设R(U)是属性集U={A1,A2,...,An}上的一个关系模式, F为R(U)的一组函数依赖, 记为R(U,F)。则有以下规则成立
      * 自反律: 若Y包含于X包含于U, 则X决定Y被F逻辑蕴涵
      * 增广律: 若X决定Y且非包含于F, 且Z包含于U, 则XZ决定YZ被F逻辑蕴涵
      * 传递律: 若X决定Y且Y决定Z, 则X决定Z被F逻辑蕴涵
    * 推论
      * 合并律: 若X决定Y且X决定Z, 则XZ决定YZ被F逻辑蕴涵
      * 伪传递律: 若X决定Y且WY决定Z, 则XW决定Z
      * 分解律: 若X决定Y且Z包含于Y, 则X决定Z
      * X决定Y可从F由公理导出, 当且仅当Y包含于属性闭包
      * F+ = G+ 等效于 F包含于G+ 且 G包含于F+
      * 每个函数依赖集F可被一个其右端至多有一个属性的函数依赖之集G覆盖
  * 属性(集)闭包
### 函数依赖集的最小覆盖
  * 覆盖: 对R(U)上的两个函数依赖集合F、G, 若$F^+=g^+$ , 则称F和G是等价的, 也称F覆盖G或者G覆盖F
  * 属性闭包的计算算法  
 ![算法](imgs/image-67.png)
  * 最小覆盖: 满足以下条件
    * F中的每个函数依赖的右部是单个属性
    * 对任何X决定A属于F, 有F-{X决定A}不等价于F
    * 对任何X决定A属于F, Z包含于X, (F-{X决定A})∪{Z决定A}不等价于F
  * 每个函数依赖集F都有等价的最小覆盖$F^+$
### 总结
![章节重难点](imgs/image-66.png)  
![本讲学习内容](imgs/image-68.png)