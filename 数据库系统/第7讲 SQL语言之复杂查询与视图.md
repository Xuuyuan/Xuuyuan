# 数据库系统 战德辰
## 第7讲 SQL语言之复杂查询与视图
### 子查询运用
**为什么需要子查询**
 * 集合成员资格判断
 * 集合之间的比较
 * 集合基数的测试(是否为空, 是否存在重复元组)

**(NOT) IN子查询**
 * 基本语法: 表达式 \[not\] in (子查询)
 * 语义: 判断某一表达式的值是否在子查询的结果中。

 * 带有子查询的selcet语句区分为内层和外层
 * 非相关子查询: 内层查询独立进行, 没有涉及任何外层查询相关信息的子查询
 * 相关子查询: 内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询, 外层向内层传递的参量需要使用外层的表名或表别名来限定
   * (只能由外层向内层传递参数, 而不能反之, 也称为变量的作用域原则)

**θ Some与θ All子查询**
 * 基本语法: 表达式 θ some/all(子查询) - θ是比较运算符
 * 语义: 将表达式的值与子查询的结果进行比较
 * 曾经有θany, 之后由于容易引起歧义, 改为了θsome
 * in 和 = some 等价, not in 和 <> all等价

**(NOT) EXISTS子查询**
 * 基本语法: \[not\] exists (子查询)
 * 语义: 子查询结果中有无元组存在

### 结果计算与聚集函数
**结果计算**
 * select子句后面可以是一些计算表达式或聚集函数, 表明在投影的同时进行计算
 * 内置的聚集函数: count(); sum(); avg(); max(); min()

### 分组查询与分组过滤
**分组查询与过滤**
 * 将检索到的元组按照某一条件进行分类, 同时处理多个组或集合的聚集运算
 * 基本语法: select ... from ... \[where ...\] group by 分组条件 \[having 过滤条件\]
 * 聚集函数不允许用于where语句中! 

### 利用SQL语言实现关系代数操作
**并-交-差处理**
 * 基本语法: 子查询 {Union \[ALL\] | Intersect \[ALL\] | Except \[ALL\] 子查询}
 * 不带ALL则默认自动删除重复元组, 若要保留则需要带有ALL
 * 交运算符intersect并没有增强sql的表达能力, 只是其增加了sql语言的不唯一性
 * 这些运算都在SQL-99中, 但有些DBMS不支持这些运算, 要注意。

**空值的处理**
 * 空值检测语法: is \[not\] null - 测试指定列的值是否为空值
 * 现行DBMS的空值处理
   * 除了is \[not\] null外不满足任何查找条件
   * 若参与算术运算, 则该算术表达式的值为null
   * 若参与比较运算, 则结果视为false
   * 若参与聚集运算, 则除了count(*)之外都忽略null

**内连接、外连接**
 * 基本语法: select 列名 from 表名1 \[NATURAL\] \[INNER|{LEFT|RIGHT|FULL}\[OUTER\]\] JOIN 表名2
 * 连接类型和连接条件  
 ![连接类型和连接条件](imgs/image-28.png)  
 ![连接时的公共属性](imgs/image-29.png)

**部分总结**  
![SQL-SELECT完整语法](imgs/image-30.png)

### 视图及其应用
 * 视图在SQL中只存储其由基本表导出视图所需要的公式, 其数据并不存储, 而是在运行过程中动态产生与维护的
 * 对视图数据的更改最终要反映在对基本表的更改上, 而有时视图定义的映射不可逆, 故视图的更新是比较复杂的问题
 * 定义视图: create view 视图名 \[(列名\[, 列名\] ...)\] as 子查询 \[with check option\]
 * 若属性名缺省, 则默认为子查询结果中的属性名
 * with check option指明当视图进行增改删时, 要检查是否满足视图定义中子查询中定义的条件表达式
 
 **SQL视图更新的可执行性**  
 ![SQL更新的可执行性](imgs/image-31.png)

 * 撤销视图: drop view 视图名
### 总结
![章节重难点](imgs/image-27.png)
![SQL: 结构化查询语言](imgs/image-32.png)